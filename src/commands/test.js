// src/commands/test.js - Comando unificado n!test (CONSOLIDADO)
import { formatReply } from '../utils/formatReply.js';
import apiRotator from '../utils/apiRotator.js';
import brainModule from '../core/brain.js';
import cooldownManager from '../modules/cooldownManager.js';
import contextIntelligence from '../modules/contextIntelligence.js';
import affectionService from '../modules/affectionService.js';
import { EmbedBuilder } from 'discord.js';

export default {
  commandName: 'test',
  description: 'Comando unificado para testar todos os sistemas da Alice',
  category: 'sistema',
  aliases: ['teste', 't', 'debug'],

  async execute(message, client) {
    console.log(`[TEST-COMMAND] üß™ Executando comando test unificado para ${message.author.username}`);

    try {
      const args = message.content.split(' ').slice(1);
      const testType = args[0]?.toLowerCase() || 'basic';

      switch (testType) {
        case 'basic':
        case 'comando':
          await this.testBasic(message);
          break;
          
        case 'modelos':
        case 'models':
        case 'ia':
          await this.testModels(message, args[1]);
          break;
          
        case 'sistemas':
        case 'systems':
        case 'brain':
          await this.testSystems(message, args[1]);
          break;
          
        case 'config':
        case 'configuracao':
          await this.testConfig(message);
          break;
          
        case 'melhorias':
        case 'improvements':
          await this.testImprovements(message);
          break;
          
        case 'status':
        case 'info':
          await this.showStatus(message);
          break;
          
        default:
          await this.showHelp(message);
      }
    } catch (error) {
      console.error(`[TEST-COMMAND] üí• Erro:`, error.message);
      await message.reply(formatReply('Ops! Tive um probleminha no teste... üòÖ'));
    }
  },

  // Teste b√°sico de comando
  async testBasic(message) {
    const testResponse = `üß™ **Teste B√°sico do Sistema**\n\n` +
      `‚úÖ Comando executado com sucesso!\n` +
      `üë§ Usu√°rio: ${message.author.username}\n` +
      `üìù Comando: ${message.content}\n` +
      `‚è∞ Timestamp: ${new Date().toLocaleString()}\n\n` +
      `üéØ Sistema de comandos funcionando perfeitamente!`;
    
    await message.reply(formatReply(testResponse));
  },

  // Teste de modelos de IA
  async testModels(message, mode = 'simple') {
    console.log(`[TEST-MODELS] ü§ñ Testando modelos (modo: ${mode})`);
    
    try {
      const stats = apiRotator.getStats();
      const activeModels = stats.models.filter(m => m.isActive);
      
      if (activeModels.length === 0) {
        await message.reply(formatReply('‚ùå Nenhum modelo ativo encontrado!'));
        return;
      }

      let modelsToTest = [];
      let testMessage = '';

      switch (mode) {
        case 'all':
          modelsToTest = activeModels;
          testMessage = `üß™ **TESTE COMPLETO DE MODELOS**\n\nTestando ${modelsToTest.length} modelos ativos...\n‚è≥ Isso pode levar alguns minutos!`;
          break;
        case 'gradual':
          modelsToTest = activeModels.slice(0, 5); // Apenas 5 para teste gradual
          testMessage = `üß™ **TESTE GRADUAL DE MODELOS**\n\nTestando ${modelsToTest.length} modelos com delays...\n‚è≥ Isso pode levar alguns minutos!`;
          break;
        default: // simple
          modelsToTest = activeModels.slice(0, 3); // Apenas 3 para teste simples
          testMessage = `üß™ **TESTE SIMPLES DE MODELOS**\n\nTestando ${modelsToTest.length} modelos principais...`;
      }

      await message.reply(formatReply(testMessage));

      const results = {
        working: [],
        failed: [],
        rateLimited: []
      };

      for (let i = 0; i < modelsToTest.length; i++) {
        const model = modelsToTest[i];
        
        try {
          if (mode === 'gradual') {
            await message.reply(formatReply(`üß™ Testando: ${model.name}`));
            await new Promise(resolve => setTimeout(resolve, 2000)); // Delay de 2s
          }
          
          const startTime = Date.now();
          const response = await apiRotator.generateResponse('Teste de conectividade', model.name);
          const responseTime = Date.now() - startTime;
          
          results.working.push({
            name: model.name,
            responseTime: responseTime,
            response: response.substring(0, 100) + '...'
          });
          
          if (mode !== 'gradual') {
            await message.reply(formatReply(`‚úÖ ${model.name}: ${responseTime}ms`));
          }
          
        } catch (error) {
          results.failed.push({
            name: model.name,
            error: error.message
          });
          
          if (mode !== 'gradual') {
            await message.reply(formatReply(`‚ùå ${model.name}: ${error.message}`));
          }
        }
      }

      // Resultado final
      const embed = new EmbedBuilder()
        .setColor('#00ff88')
        .setTitle('üß™ Resultado dos Testes de Modelos')
        .addFields(
          { name: '‚úÖ Funcionando', value: results.working.length.toString(), inline: true },
          { name: '‚ùå Falharam', value: results.failed.length.toString(), inline: true },
          { name: '‚è±Ô∏è Tempo M√©dio', value: results.working.length > 0 ? `${Math.round(results.working.reduce((a, b) => a + b.responseTime, 0) / results.working.length)}ms` : 'N/A', inline: true }
        );

      if (results.working.length > 0) {
        embed.addFields({
          name: 'üéØ Modelos Funcionando',
          value: results.working.map(m => `‚Ä¢ ${m.name} (${m.responseTime}ms)`).join('\n'),
          inline: false
        });
      }

      if (results.failed.length > 0) {
        embed.addFields({
          name: 'üí• Modelos com Problema',
          value: results.failed.map(m => `‚Ä¢ ${m.name}: ${m.error}`).join('\n'),
          inline: false
        });
      }

      await message.reply({ embeds: [embed] });

    } catch (error) {
      console.error(`[TEST-MODELS] üí• Erro:`, error.message);
      await message.reply(formatReply('Ops! Erro ao testar modelos... üòÖ'));
    }
  },

  // Teste de sistemas internos
  async testSystems(message, system = 'all') {
    console.log(`[TEST-SYSTEMS] üß† Testando sistemas (${system})`);
    
    try {
      const { getCompleteStats, getBrainStatus } = brainModule;
      
      if (system === 'all' || system === 'brain') {
        const brainStats = getCompleteStats();
        await message.reply(formatReply(`üß† **Sistema Cerebral:**\n${JSON.stringify(brainStats, null, 2).substring(0, 1000)}...`));
      }
      
      if (system === 'all' || system === 'memory') {
        const memoryStats = await contextIntelligence.analyzeUserContext(message.guild?.id || 'dm', message.author.id, message.channel.id);
        await message.reply(formatReply(`üíæ **Sistema de Mem√≥ria:**\n${JSON.stringify(memoryStats, null, 2).substring(0, 1000)}...`));
      }
      
    } catch (error) {
      console.error(`[TEST-SYSTEMS] üí• Erro:`, error.message);
      await message.reply(formatReply('Ops! Erro ao testar sistemas... üòÖ'));
    }
  },

  // Teste de configura√ß√£o
  async testConfig(message) {
    console.log(`[TEST-CONFIG] üîß Testando configura√ß√£o`);
    
    const config = {
      discordToken: process.env.DISCORD_TOKEN ? '‚úÖ Configurado' : '‚ùå N√£o configurado',
      openrouterKey: process.env.OPENROUTER_API_KEY ? '‚úÖ Configurado' : '‚ùå N√£o configurado',
      discordClientId: process.env.DISCORD_CLIENT_ID ? '‚úÖ Configurado' : '‚ö†Ô∏è Opcional',
      discordAppId: process.env.DISCORD_APPLICATION_ID ? '‚úÖ Configurado' : '‚ö†Ô∏è Opcional',
      discordPublicKey: process.env.DISCORD_PUBLIC_KEY ? '‚úÖ Configurado' : '‚ö†Ô∏è Opcional'
    };
    
    let tokenFormat = '‚ùå Inv√°lido';
    if (process.env.DISCORD_TOKEN) {
      const token = process.env.DISCORD_TOKEN;
      if (token.startsWith('MT') || token.startsWith('MTA')) {
        tokenFormat = '‚úÖ Formato correto';
      } else {
        tokenFormat = '‚ùå Formato incorreto (deve come√ßar com MT ou MTA)';
      }
    }
    
    const configText = `üîß **Teste de Configura√ß√£o**\n\n` +
      `**Vari√°veis de Ambiente:**\n` +
      `‚Ä¢ Discord Token: ${config.discordToken}\n` +
      `‚Ä¢ OpenRouter Key: ${config.openrouterKey}\n` +
      `‚Ä¢ Discord Client ID: ${config.discordClientId}\n` +
      `‚Ä¢ Discord App ID: ${config.discordAppId}\n` +
      `‚Ä¢ Discord Public Key: ${config.discordPublicKey}\n\n` +
      `**Formato do Token:** ${tokenFormat}\n\n` +
      `**Node.js:** ${process.version}\n` +
      `**Plataforma:** ${process.platform}\n` +
      `**Arquitetura:** ${process.arch}`;
    
    await message.reply(formatReply(configText));
  },

  // Teste de melhorias
  async testImprovements(message) {
    console.log(`[TEST-IMPROVEMENTS] üöÄ Testando melhorias`);
    
    try {
      const guildId = message.guild?.id || 'dm';
      const channelId = message.channel.id;
      const userId = message.author.id;
      
      const cooldownStats = cooldownManager.getStats();
      const userContext = await contextIntelligence.analyzeUserContext(guildId, userId, channelId);
      const affectionStats = await affectionService.getUserStats(guildId, userId);
      
      const improvementsText = `üöÄ **Teste de Melhorias Implementadas**\n\n` +
        `**Cooldown Manager:**\n` +
        `‚Ä¢ Cache Size: ${cooldownStats.cacheSize}\n` +
        `‚Ä¢ Total Commands: ${cooldownStats.totalCommands}\n\n` +
        `**Context Intelligence:**\n` +
        `‚Ä¢ Affection Level: ${userContext.affectionLevelName}\n` +
        `‚Ä¢ Relationship: ${userContext.relationshipStatus}\n\n` +
        `**Affection Service:**\n` +
        `‚Ä¢ Total Interactions: ${affectionStats.totalInteractions}\n` +
        `‚Ä¢ Affection Level: ${affectionStats.affectionLevel}`;
      
      await message.reply(formatReply(improvementsText));
      
    } catch (error) {
      console.error(`[TEST-IMPROVEMENTS] üí• Erro:`, error.message);
      await message.reply(formatReply('Ops! Erro ao testar melhorias... üòÖ'));
    }
  },

  // Status geral
  async showStatus(message) {
    console.log(`[TEST-STATUS] üìä Mostrando status geral`);
    
    try {
      const apiStats = apiRotator.getStats();
      const uptime = process.uptime();
      const hours = Math.floor(uptime / 3600);
      const minutes = Math.floor((uptime % 3600) / 60);
      
      const statusText = `üìä **Status Geral do Sistema**\n\n` +
        `üü¢ **Status:** Online e funcionando\n` +
        `‚è∞ **Uptime:** ${hours}h ${minutes}m\n` +
        `üíæ **Mem√≥ria:** ${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)}MB\n` +
        `ü§ñ **Modelos Ativos:** ${apiStats.models.filter(m => m.isActive).length}\n` +
        `üìà **Total de Requisi√ß√µes:** ${apiStats.totalRequests}\n` +
        `‚úÖ **Taxa de Sucesso:** ${apiStats.successRate}%`;
      
      await message.reply(formatReply(statusText));
      
    } catch (error) {
      console.error(`[TEST-STATUS] üí• Erro:`, error.message);
      await message.reply(formatReply('Ops! Erro ao mostrar status... üòÖ'));
    }
  },

  // Ajuda
  async showHelp(message) {
    const helpText = `üß™ **Comando de Teste Unificado**\n\n` +
      `**Uso:** \`n!test [tipo]\`\n\n` +
      `**Tipos dispon√≠veis:**\n` +
      `‚Ä¢ \`n!test\` ou \`n!test basic\` - Teste b√°sico de comando\n` +
      `‚Ä¢ \`n!test modelos\` - Teste simples de modelos de IA\n` +
      `‚Ä¢ \`n!test modelos all\` - Teste completo de todos os modelos\n` +
      `‚Ä¢ \`n!test modelos gradual\` - Teste gradual com delays\n` +
      `‚Ä¢ \`n!test sistemas\` - Teste de sistemas internos\n` +
      `‚Ä¢ \`n!test config\` - Teste de configura√ß√£o\n` +
      `‚Ä¢ \`n!test melhorias\` - Teste de melhorias implementadas\n` +
      `‚Ä¢ \`n!test status\` - Status geral do sistema\n\n` +
      `**Exemplos:**\n` +
      `‚Ä¢ \`n!test\`\n` +
      `‚Ä¢ \`n!test modelos\`\n` +
      `‚Ä¢ \`n!test sistemas brain\`\n` +
      `‚Ä¢ \`n!test config\``;
    
    await message.reply(formatReply(helpText));
  }
};
